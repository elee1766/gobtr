package btrfs

import (
	"bytes"
	"context"
	"fmt"
	"os/exec"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/google/uuid"
)

type BalanceStatus struct {
	UUID             string // Balance UUID (generated by us)
	IsRunning        bool
	IsPaused         bool
	Status           string
	TotalChunks      int64
	Considered       int64
	Left             int64
	Relocated        int64
	SizeTotal        int64
	SizeRelocated    int64
	SoftErrors       int32
	Duration         string
	DurationSeconds  int64
	StartedAt        time.Time
	FinishedAt       time.Time
}

type activeBalance struct {
	ctx    context.Context
	cancel context.CancelFunc
	id     string
}

// BalanceOptions contains options for starting a balance
type BalanceOptions struct {
	Data         bool
	Metadata     bool
	System       bool
	UsagePercent int32 // Balance chunks with usage <= this percent (0 = disabled)
	LimitChunks  int64 // Limit number of chunks to process (0 = no limit)
	LimitPercent int32 // Throughput limit as percentage (0 = unlimited)
	Background   bool
	DryRun       bool
	Force        bool
}

// Track active balances per device
var (
	activeBalances = make(map[string]*activeBalance)
	balanceMutex   sync.Mutex
)

// StartBalance starts a balance operation on a device
func (m *Manager) StartBalance(ctx context.Context, devicePath string, opts BalanceOptions) (string, error) {
	balanceMutex.Lock()
	if active, exists := activeBalances[devicePath]; exists && !opts.Force {
		balanceMutex.Unlock()
		return active.id, fmt.Errorf("balance already running on %s", devicePath)
	}

	balanceID := uuid.New().String()
	balanceCtx, cancel := context.WithCancel(ctx)
	activeBalances[devicePath] = &activeBalance{
		ctx:    balanceCtx,
		cancel: cancel,
		id:     balanceID,
	}
	balanceMutex.Unlock()

	args := []string{"balance", "start"}

	// Build filter arguments
	filters := []string{}
	if opts.Data {
		filter := "dprofiles=data"
		if opts.UsagePercent > 0 {
			filter += fmt.Sprintf(",usage=%d", opts.UsagePercent)
		}
		if opts.LimitChunks > 0 {
			filter += fmt.Sprintf(",limit=%d", opts.LimitChunks)
		}
		filters = append(filters, filter)
	}
	if opts.Metadata {
		filter := "mprofiles=metadata"
		if opts.UsagePercent > 0 {
			filter += fmt.Sprintf(",usage=%d", opts.UsagePercent)
		}
		if opts.LimitChunks > 0 {
			filter += fmt.Sprintf(",limit=%d", opts.LimitChunks)
		}
		filters = append(filters, filter)
	}
	if opts.System {
		filter := "sprofiles=system"
		if opts.UsagePercent > 0 {
			filter += fmt.Sprintf(",usage=%d", opts.UsagePercent)
		}
		if opts.LimitChunks > 0 {
			filter += fmt.Sprintf(",limit=%d", opts.LimitChunks)
		}
		filters = append(filters, filter)
	}

	// If no specific type selected, balance all with usage filter if provided
	if !opts.Data && !opts.Metadata && !opts.System {
		if opts.UsagePercent > 0 {
			args = append(args, "-dusage="+strconv.Itoa(int(opts.UsagePercent)))
			args = append(args, "-musage="+strconv.Itoa(int(opts.UsagePercent)))
		}
		if opts.LimitChunks > 0 {
			args = append(args, "-dlimit="+strconv.Itoa(int(opts.LimitChunks)))
			args = append(args, "-mlimit="+strconv.Itoa(int(opts.LimitChunks)))
		}
	} else {
		for _, f := range filters {
			args = append(args, "-"+f)
		}
	}

	if opts.Force {
		args = append(args, "-f")
	}

	// Note: --limit for throughput is not universally supported in btrfs balance
	// Background mode runs with ionice/nice but we just run in a goroutine

	args = append(args, devicePath)

	cmd := exec.CommandContext(balanceCtx, "btrfs", args...)
	var out bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &out

	go func() {
		err := cmd.Run()
		balanceMutex.Lock()
		delete(activeBalances, devicePath)
		balanceMutex.Unlock()

		if err != nil && balanceCtx.Err() == nil {
			m.logger.Error("balance failed", "device", devicePath, "error", err, "output", out.String())
		} else {
			m.logger.Info("balance completed", "device", devicePath, "output", out.String())
		}
	}()

	m.logger.Info("balance started", "device", devicePath, "balance_id", balanceID, "opts", opts)
	return balanceID, nil
}

// CancelBalance cancels a running balance
func (m *Manager) CancelBalance(devicePath string) error {
	balanceMutex.Lock()
	active, exists := activeBalances[devicePath]
	if !exists {
		balanceMutex.Unlock()
		return fmt.Errorf("no active balance on %s", devicePath)
	}
	balanceMutex.Unlock()

	// Cancel the context
	active.cancel()

	// Also try to cancel via btrfs command
	cmd := exec.Command("btrfs", "balance", "cancel", devicePath)
	var out bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &out

	if err := cmd.Run(); err != nil {
		m.logger.Warn("btrfs balance cancel command failed", "error", err, "output", out.String())
		// Don't return error as we already canceled via context
	}

	m.logger.Info("balance canceled", "device", devicePath)
	return nil
}

// PauseBalance pauses a running balance
func (m *Manager) PauseBalance(devicePath string) error {
	cmd := exec.Command("btrfs", "balance", "pause", devicePath)
	var out bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &out

	if err := cmd.Run(); err != nil {
		m.logger.Error("failed to pause balance", "error", err, "output", out.String())
		return fmt.Errorf("btrfs balance pause failed: %w", err)
	}

	m.logger.Info("balance paused", "device", devicePath)
	return nil
}

// ResumeBalance resumes a paused balance
func (m *Manager) ResumeBalance(ctx context.Context, devicePath string) error {
	cmd := exec.CommandContext(ctx, "btrfs", "balance", "resume", devicePath)
	var out bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &out

	if err := cmd.Run(); err != nil {
		m.logger.Error("failed to resume balance", "error", err, "output", out.String())
		return fmt.Errorf("btrfs balance resume failed: %w", err)
	}

	m.logger.Info("balance resumed", "device", devicePath)
	return nil
}

// GetBalanceStatus gets the current balance status
func (m *Manager) GetBalanceStatus(devicePath string) (*BalanceStatus, error) {
	cmd := exec.Command("btrfs", "balance", "status", devicePath)
	var out bytes.Buffer
	cmd.Stdout = &out
	cmd.Stderr = &out

	err := cmd.Run()
	output := out.String()

	// Balance status returns non-zero if no balance is running, which is fine
	if err != nil {
		if strings.Contains(output, "No balance found") || strings.Contains(output, "not in progress") {
			return &BalanceStatus{Status: "idle"}, nil
		}
		m.logger.Debug("balance status output", "output", output, "error", err)
	}

	return m.parseBalanceStatus(output, devicePath)
}

func (m *Manager) parseBalanceStatus(output, devicePath string) (*BalanceStatus, error) {
	status := &BalanceStatus{}

	if strings.Contains(output, "No balance found") || strings.Contains(output, "not in progress") {
		status.Status = "idle"
		return status, nil
	}

	// Check if running or paused
	if strings.Contains(output, "Balance on") {
		if strings.Contains(output, "is running") {
			status.IsRunning = true
			status.Status = "running"
		} else if strings.Contains(output, "is paused") {
			status.IsPaused = true
			status.Status = "paused"
		}
	}

	// Parse progress: "X out of about Y chunks balanced (Z considered)"
	// Or: "X out of about Y chunks balanced"
	progressRe := regexp.MustCompile(`(\d+)\s+out of about\s+(\d+)\s+chunks balanced(?:\s+\((\d+)\s+considered\))?`)
	if matches := progressRe.FindStringSubmatch(output); len(matches) >= 3 {
		status.Relocated, _ = strconv.ParseInt(matches[1], 10, 64)
		status.TotalChunks, _ = strconv.ParseInt(matches[2], 10, 64)
		if len(matches) >= 4 && matches[3] != "" {
			status.Considered, _ = strconv.ParseInt(matches[3], 10, 64)
		}
		status.Left = status.TotalChunks - status.Relocated
	}

	// Parse soft errors
	errRe := regexp.MustCompile(`(\d+)\s+soft error`)
	if matches := errRe.FindStringSubmatch(output); len(matches) == 2 {
		val, _ := strconv.ParseInt(matches[1], 10, 32)
		status.SoftErrors = int32(val)
	}

	// Parse expected time remaining if present
	// "expected to finish in X hour(s), Y minute(s)"

	return status, nil
}

// IsBalanceRunning checks if a balance is currently running
func (m *Manager) IsBalanceRunning(devicePath string) bool {
	balanceMutex.Lock()
	defer balanceMutex.Unlock()
	_, exists := activeBalances[devicePath]
	return exists
}

// GetActiveBalanceID returns the ID of the active balance if any
func (m *Manager) GetActiveBalanceID(devicePath string) string {
	balanceMutex.Lock()
	defer balanceMutex.Unlock()
	if active, exists := activeBalances[devicePath]; exists {
		return active.id
	}
	return ""
}
