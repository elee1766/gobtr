// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: api/v1/fragmap.proto

package apiv1connect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	v1 "github.com/elee1766/gobtr/gen/api/v1"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// FragMapServiceName is the fully-qualified name of the FragMapService service.
	FragMapServiceName = "api.v1.FragMapService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// FragMapServiceGetFragMapProcedure is the fully-qualified name of the FragMapService's GetFragMap
	// RPC.
	FragMapServiceGetFragMapProcedure = "/api.v1.FragMapService/GetFragMap"
	// FragMapServiceGetDeviceBlockMapProcedure is the fully-qualified name of the FragMapService's
	// GetDeviceBlockMap RPC.
	FragMapServiceGetDeviceBlockMapProcedure = "/api.v1.FragMapService/GetDeviceBlockMap"
	// FragMapServiceGetDeviceBlockMapsProcedure is the fully-qualified name of the FragMapService's
	// GetDeviceBlockMaps RPC.
	FragMapServiceGetDeviceBlockMapsProcedure = "/api.v1.FragMapService/GetDeviceBlockMaps"
	// FragMapServiceGetHeatMapProcedure is the fully-qualified name of the FragMapService's GetHeatMap
	// RPC.
	FragMapServiceGetHeatMapProcedure = "/api.v1.FragMapService/GetHeatMap"
	// FragMapServiceGetFragStatsProcedure is the fully-qualified name of the FragMapService's
	// GetFragStats RPC.
	FragMapServiceGetFragStatsProcedure = "/api.v1.FragMapService/GetFragStats"
)

// FragMapServiceClient is a client for the api.v1.FragMapService service.
type FragMapServiceClient interface {
	// Get the complete fragmentation map for a filesystem
	GetFragMap(context.Context, *connect.Request[v1.GetFragMapRequest]) (*connect.Response[v1.GetFragMapResponse], error)
	// Get block map data for a specific device
	GetDeviceBlockMap(context.Context, *connect.Request[v1.GetDeviceBlockMapRequest]) (*connect.Response[v1.GetDeviceBlockMapResponse], error)
	// Get block maps for multiple devices in parallel
	GetDeviceBlockMaps(context.Context, *connect.Request[v1.GetDeviceBlockMapsRequest]) (*connect.Response[v1.GetDeviceBlockMapsResponse], error)
	// Get heat map data for visualization
	GetHeatMap(context.Context, *connect.Request[v1.GetHeatMapRequest]) (*connect.Response[v1.GetHeatMapResponse], error)
	// Get fragmentation statistics
	GetFragStats(context.Context, *connect.Request[v1.GetFragStatsRequest]) (*connect.Response[v1.GetFragStatsResponse], error)
}

// NewFragMapServiceClient constructs a client for the api.v1.FragMapService service. By default, it
// uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewFragMapServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) FragMapServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	fragMapServiceMethods := v1.File_api_v1_fragmap_proto.Services().ByName("FragMapService").Methods()
	return &fragMapServiceClient{
		getFragMap: connect.NewClient[v1.GetFragMapRequest, v1.GetFragMapResponse](
			httpClient,
			baseURL+FragMapServiceGetFragMapProcedure,
			connect.WithSchema(fragMapServiceMethods.ByName("GetFragMap")),
			connect.WithClientOptions(opts...),
		),
		getDeviceBlockMap: connect.NewClient[v1.GetDeviceBlockMapRequest, v1.GetDeviceBlockMapResponse](
			httpClient,
			baseURL+FragMapServiceGetDeviceBlockMapProcedure,
			connect.WithSchema(fragMapServiceMethods.ByName("GetDeviceBlockMap")),
			connect.WithClientOptions(opts...),
		),
		getDeviceBlockMaps: connect.NewClient[v1.GetDeviceBlockMapsRequest, v1.GetDeviceBlockMapsResponse](
			httpClient,
			baseURL+FragMapServiceGetDeviceBlockMapsProcedure,
			connect.WithSchema(fragMapServiceMethods.ByName("GetDeviceBlockMaps")),
			connect.WithClientOptions(opts...),
		),
		getHeatMap: connect.NewClient[v1.GetHeatMapRequest, v1.GetHeatMapResponse](
			httpClient,
			baseURL+FragMapServiceGetHeatMapProcedure,
			connect.WithSchema(fragMapServiceMethods.ByName("GetHeatMap")),
			connect.WithClientOptions(opts...),
		),
		getFragStats: connect.NewClient[v1.GetFragStatsRequest, v1.GetFragStatsResponse](
			httpClient,
			baseURL+FragMapServiceGetFragStatsProcedure,
			connect.WithSchema(fragMapServiceMethods.ByName("GetFragStats")),
			connect.WithClientOptions(opts...),
		),
	}
}

// fragMapServiceClient implements FragMapServiceClient.
type fragMapServiceClient struct {
	getFragMap         *connect.Client[v1.GetFragMapRequest, v1.GetFragMapResponse]
	getDeviceBlockMap  *connect.Client[v1.GetDeviceBlockMapRequest, v1.GetDeviceBlockMapResponse]
	getDeviceBlockMaps *connect.Client[v1.GetDeviceBlockMapsRequest, v1.GetDeviceBlockMapsResponse]
	getHeatMap         *connect.Client[v1.GetHeatMapRequest, v1.GetHeatMapResponse]
	getFragStats       *connect.Client[v1.GetFragStatsRequest, v1.GetFragStatsResponse]
}

// GetFragMap calls api.v1.FragMapService.GetFragMap.
func (c *fragMapServiceClient) GetFragMap(ctx context.Context, req *connect.Request[v1.GetFragMapRequest]) (*connect.Response[v1.GetFragMapResponse], error) {
	return c.getFragMap.CallUnary(ctx, req)
}

// GetDeviceBlockMap calls api.v1.FragMapService.GetDeviceBlockMap.
func (c *fragMapServiceClient) GetDeviceBlockMap(ctx context.Context, req *connect.Request[v1.GetDeviceBlockMapRequest]) (*connect.Response[v1.GetDeviceBlockMapResponse], error) {
	return c.getDeviceBlockMap.CallUnary(ctx, req)
}

// GetDeviceBlockMaps calls api.v1.FragMapService.GetDeviceBlockMaps.
func (c *fragMapServiceClient) GetDeviceBlockMaps(ctx context.Context, req *connect.Request[v1.GetDeviceBlockMapsRequest]) (*connect.Response[v1.GetDeviceBlockMapsResponse], error) {
	return c.getDeviceBlockMaps.CallUnary(ctx, req)
}

// GetHeatMap calls api.v1.FragMapService.GetHeatMap.
func (c *fragMapServiceClient) GetHeatMap(ctx context.Context, req *connect.Request[v1.GetHeatMapRequest]) (*connect.Response[v1.GetHeatMapResponse], error) {
	return c.getHeatMap.CallUnary(ctx, req)
}

// GetFragStats calls api.v1.FragMapService.GetFragStats.
func (c *fragMapServiceClient) GetFragStats(ctx context.Context, req *connect.Request[v1.GetFragStatsRequest]) (*connect.Response[v1.GetFragStatsResponse], error) {
	return c.getFragStats.CallUnary(ctx, req)
}

// FragMapServiceHandler is an implementation of the api.v1.FragMapService service.
type FragMapServiceHandler interface {
	// Get the complete fragmentation map for a filesystem
	GetFragMap(context.Context, *connect.Request[v1.GetFragMapRequest]) (*connect.Response[v1.GetFragMapResponse], error)
	// Get block map data for a specific device
	GetDeviceBlockMap(context.Context, *connect.Request[v1.GetDeviceBlockMapRequest]) (*connect.Response[v1.GetDeviceBlockMapResponse], error)
	// Get block maps for multiple devices in parallel
	GetDeviceBlockMaps(context.Context, *connect.Request[v1.GetDeviceBlockMapsRequest]) (*connect.Response[v1.GetDeviceBlockMapsResponse], error)
	// Get heat map data for visualization
	GetHeatMap(context.Context, *connect.Request[v1.GetHeatMapRequest]) (*connect.Response[v1.GetHeatMapResponse], error)
	// Get fragmentation statistics
	GetFragStats(context.Context, *connect.Request[v1.GetFragStatsRequest]) (*connect.Response[v1.GetFragStatsResponse], error)
}

// NewFragMapServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewFragMapServiceHandler(svc FragMapServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	fragMapServiceMethods := v1.File_api_v1_fragmap_proto.Services().ByName("FragMapService").Methods()
	fragMapServiceGetFragMapHandler := connect.NewUnaryHandler(
		FragMapServiceGetFragMapProcedure,
		svc.GetFragMap,
		connect.WithSchema(fragMapServiceMethods.ByName("GetFragMap")),
		connect.WithHandlerOptions(opts...),
	)
	fragMapServiceGetDeviceBlockMapHandler := connect.NewUnaryHandler(
		FragMapServiceGetDeviceBlockMapProcedure,
		svc.GetDeviceBlockMap,
		connect.WithSchema(fragMapServiceMethods.ByName("GetDeviceBlockMap")),
		connect.WithHandlerOptions(opts...),
	)
	fragMapServiceGetDeviceBlockMapsHandler := connect.NewUnaryHandler(
		FragMapServiceGetDeviceBlockMapsProcedure,
		svc.GetDeviceBlockMaps,
		connect.WithSchema(fragMapServiceMethods.ByName("GetDeviceBlockMaps")),
		connect.WithHandlerOptions(opts...),
	)
	fragMapServiceGetHeatMapHandler := connect.NewUnaryHandler(
		FragMapServiceGetHeatMapProcedure,
		svc.GetHeatMap,
		connect.WithSchema(fragMapServiceMethods.ByName("GetHeatMap")),
		connect.WithHandlerOptions(opts...),
	)
	fragMapServiceGetFragStatsHandler := connect.NewUnaryHandler(
		FragMapServiceGetFragStatsProcedure,
		svc.GetFragStats,
		connect.WithSchema(fragMapServiceMethods.ByName("GetFragStats")),
		connect.WithHandlerOptions(opts...),
	)
	return "/api.v1.FragMapService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case FragMapServiceGetFragMapProcedure:
			fragMapServiceGetFragMapHandler.ServeHTTP(w, r)
		case FragMapServiceGetDeviceBlockMapProcedure:
			fragMapServiceGetDeviceBlockMapHandler.ServeHTTP(w, r)
		case FragMapServiceGetDeviceBlockMapsProcedure:
			fragMapServiceGetDeviceBlockMapsHandler.ServeHTTP(w, r)
		case FragMapServiceGetHeatMapProcedure:
			fragMapServiceGetHeatMapHandler.ServeHTTP(w, r)
		case FragMapServiceGetFragStatsProcedure:
			fragMapServiceGetFragStatsHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedFragMapServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedFragMapServiceHandler struct{}

func (UnimplementedFragMapServiceHandler) GetFragMap(context.Context, *connect.Request[v1.GetFragMapRequest]) (*connect.Response[v1.GetFragMapResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("api.v1.FragMapService.GetFragMap is not implemented"))
}

func (UnimplementedFragMapServiceHandler) GetDeviceBlockMap(context.Context, *connect.Request[v1.GetDeviceBlockMapRequest]) (*connect.Response[v1.GetDeviceBlockMapResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("api.v1.FragMapService.GetDeviceBlockMap is not implemented"))
}

func (UnimplementedFragMapServiceHandler) GetDeviceBlockMaps(context.Context, *connect.Request[v1.GetDeviceBlockMapsRequest]) (*connect.Response[v1.GetDeviceBlockMapsResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("api.v1.FragMapService.GetDeviceBlockMaps is not implemented"))
}

func (UnimplementedFragMapServiceHandler) GetHeatMap(context.Context, *connect.Request[v1.GetHeatMapRequest]) (*connect.Response[v1.GetHeatMapResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("api.v1.FragMapService.GetHeatMap is not implemented"))
}

func (UnimplementedFragMapServiceHandler) GetFragStats(context.Context, *connect.Request[v1.GetFragStatsRequest]) (*connect.Response[v1.GetFragStatsResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("api.v1.FragMapService.GetFragStats is not implemented"))
}
